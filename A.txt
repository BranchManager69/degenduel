Understanding DegenDuel's Market Data & Token Architecture

  After analyzing the codebase thoroughly, I've developed a comprehensive picture of your token data system's evolution
  and current state. Here's my understanding of what happened, why it's problematic, and the architectural challenges
  we're facing.

  Original Architecture (Two-Server Setup)

  Your system originally spanned two servers with distinct responsibilities:

  1. Market Data Server: External server dedicated to:
    - Collecting token price data
    - Storing market statistics
    - Maintaining market_cap, volume_24h and other metrics
    - Storing this data in its own PostgreSQL database (degenduel_market_data)
  2. DegenDuel Core Server: Main application server handling:
    - User interactions, contests, trades
    - Web client connections
    - Needing token data but not responsible for sourcing it
    - References to tokens in its own database (degenduel primary DB)

  The Token Synchronization Problem

  This created the original synchronization challenge:
  - The Market Data Server knew about tokens (prices, volumes, etc.)
  - The DegenDuel Server needed to know which tokens existed
  - TokenSyncService was created to bridge this gap by:
    - Periodically checking the Market Data Server
    - Synchronizing token lists between the two systems
    - Ensuring new tokens discovered by the market data system would propagate to DegenDuel

  Current Architecture (Single-Server Problem)

  Now everything runs on one server, but the architecture still operates as if two servers exist:

  1. MarketDataService:
    - Connects to degenduel_market_data database (now local)
    - Periodically (every 10 seconds) fetches token data
    - Broadcasts this data via serviceEvents.emit('market:broadcast', enhancedBroadcastData)
    - Acts like it's still an independent system
  2. TokenSyncService (now redundant):
    - Still operates as if syncing between two systems
    - Essentially moving data between two databases on the same server
    - Creating unnecessary processing overhead
  3. Two WebSocket Systems consuming the same data:
    - TokenDataWebSocket (older implementation)
    - MarketDataWebSocketServer (v69 implementation)
    - Both listening to the same 'market:broadcast' event
    - Both forwarding data to clients
    - Potentially causing duplicate broadcasts

  The Chicken and Egg Problem

  You mentioned a "chicken and egg" problem where:
  1. You needed to know which tokens to track (addresses)
  2. But you also needed to collect data on those tokens
  3. So TokenWhitelistService was meant to be the source of truth about which tokens should be tracked
  4. Then TokenSyncService would ensure both databases knew about these tokens
  5. Then MarketDataService would collect and broadcast data about these tokens

  Key Issues Identified

  1. Redundant Data Flow: Data is flowing from one local database to another local database, then to two different
  WebSocket servers, all on the same physical machine.
  2. Double Broadcasting: Two WebSocket servers are consuming and broadcasting the same market data event, potentially
  to different sets of clients.
  3. Unnecessary Synchronization: TokenSyncService is synchronizing between databases that are now local to each other,
  creating overhead without adding value.
  4. Architectural Mismatch: The code is structured as if MarketDataService is an external system, when it's now just
  another service in the same application.
  5. Confusing Responsibility: There's ambiguity about which service should be responsible for managing the list of
  tokens to track (TokenWhitelistService vs TokenSyncService).

  Core Components Breakdown

  MarketDataService

  This service:
  - Connects to the market_data database (degenduel_market_data)
  - Fetches token data (prices, market caps, etc.)
  - Maintains a cache of token data
  - Broadcasts token data updates via market:broadcast event
  - Has a 10-second broadcast interval for updates
  - Is correctly named as it deals with market data (prices, volumes)

  TokenSyncService

  This service:
  - Synchronizes token metadata between databases
  - Updates the primary database with new tokens
  - Ensures token references exist in both systems
  - Is redundant in the single-server architecture
  - Is correctly named for its original purpose (syncing tokens between servers)

  TokenWhitelistService

  This service:
  - Manages which tokens should be tracked in the system
  - Acts as a gatekeeper for token addition/removal
  - Has become disconnected from the actual flow
  - Is correctly named for its purpose (managing the "whitelist" of allowed tokens)

  WebSocket Architecture Issues

  One of the major issues is the way WebSockets are set up:

  1. MarketDataWebSocketServer (v69) in websocket/v69/market-data-ws.js:
    - Modern implementation that handles both token data and market data
    - Listens to 'market:broadcast' events
    - Has client subscription management
    - Properly formats data for clients
    - Is the preferred solution for the future
  2. TokenDataWebSocket in websocket/token-data-ws.js:
    - Older implementation focused only on token metadata
    - Also listens to 'market:broadcast' events
    - Duplicates functionality now in the v69 version
    - Creates redundant broadcasts
    - Probably should be deprecated

  Data Flow Diagram

  The current flow is something like:

  MarketDataService (10s cycle)
    │
    ├─→ Query degenduel_market_data DB
    │   │
    │   ├─→ Cache token data
    │   │
    │   └─→ Emit 'market:broadcast' event ─────┬─→ MarketDataWebSocketServer ─→ WebSocket Clients
    │                                           │
    │                                           └─→ TokenDataWebSocket ─────────→ WebSocket Clients
    │
  TokenSyncService (periodic)
    │
    ├─→ Pull token data from MarketDataService
    │
    └─→ Update primary database with token metadata
        │
        └─→ (Potentially triggers other services)

  TokenWhitelistService (on-demand)
    │
    └─→ Manage the list of tokens to track
        │
        └─→ (Should influence what MarketDataService tracks but connection is unclear)

  What Should Be Happening

  A more straightforward architecture would be:

  TokenWhitelistService
    │
    ├─→ Manage the list of tokens to track
    │   │
    │   └─→ Update single source of truth in primary database
    │
  MarketDataService
    │
    ├─→ Read list of tokens to track from primary database
    │
    ├─→ Query external price sources or degenduel_market_data DB for latest data
    │
    └─→ Emit single 'market:broadcast' event ─→ Single WebSocket Server ─→ WebSocket Clients

  Conclusion

  The current system is carrying forward an architecture designed for a two-server setup that no longer exists. This has
   created redundant data flows, duplicate broadcasts, and confusion about responsibilities.

  The token synchronization between two databases on the same server is particularly problematic, as it creates overhead
   without adding value. The two WebSocket servers listening to the same event and broadcasting to potentially different
   client groups is also a source of inefficiency and potential inconsistency.

  To move forward, we need to:
  1. Decide on a single source of truth for token metadata
  2. Streamline the market data collection and broadcasting
  3. Consolidate the WebSocket implementations
  4. Clarify the role of TokenWhitelistService in the current architecture

  This should help eliminate the spaghetti code situation and create a more maintainable system.