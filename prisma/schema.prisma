generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model contest_participants {
  id                   Int           @id @default(autoincrement())
  contest_id           Int
  wallet_address       String        @db.VarChar(44)
  joined_at            DateTime      @default(now()) @db.Timestamptz(6)
  initial_dxd_points   Decimal?      @default(0) @db.Decimal(20, 0)
  current_dxd_points   Decimal?      @default(0) @db.Decimal(20, 0)
  rank                 Int?
  prize_amount         Decimal?      @db.Decimal(20, 8)
  prize_paid_at        DateTime?     @db.Timestamptz(6)
  refund_amount        Decimal?      @db.Decimal(20, 8)
  refunded_at          DateTime?     @db.Timestamptz(6)
  entry_transaction_id Int?
  entry_time           DateTime      @default(now()) @db.Timestamptz(6)
  final_rank           Int?
  prize_transaction_id Int?
  status               String        @default("active")
  portfolio_value      Decimal?      @default(0) @db.Decimal(20, 8)
  initial_balance      Decimal?      @default(0) @db.Decimal(20, 8)
  contests             contests      @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  entry_transaction    transactions? @relation("contest_participants_entry_transaction_idTotransactions", fields: [entry_transaction_id], references: [id])
  prize_transaction    transactions? @relation("contest_participants_prize_transaction_idTotransactions", fields: [prize_transaction_id], references: [id])
  users                users         @relation(fields: [wallet_address], references: [wallet_address])

  @@unique([contest_id, wallet_address])
  @@index([wallet_address])
  @@index([status])
  @@index([portfolio_value])
  @@map("contest_participants")
}

model contest_portfolios {
  id             Int      @id @default(autoincrement())
  contest_id     Int
  wallet_address String   @db.VarChar(44)
  token_id       Int
  weight         Int
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  contests       contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens   @relation(fields: [token_id], references: [id])
  users          users    @relation(fields: [wallet_address], references: [wallet_address])

  @@unique([contest_id, wallet_address, token_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_portfolios")
}

model contest_templates {
  id                  Int               @id @default(autoincrement())
  name                String
  description         String?
  duration_minutes    Int?
  entry_fee           Decimal?          @default(0) @db.Decimal(20, 0)
  max_participants    Int?              @default(2)
  bucket_requirements Json?             @default("{}")
  scoring_rules       Json?             @default("{}")
  is_active           Boolean?          @default(true)
  created_at          DateTime?         @default(now()) @db.Timestamptz(6)
  schedule            contest_schedule[]

  @@index([name], map: "idx_contest_templates_name")
  @@map("contest_templates")
}

model contest_token_buckets {
  contest_id Int
  token_id   Int
  bucket_id  Int
  contests   contests @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens     tokens   @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([contest_id, token_id, bucket_id])
  @@index([contest_id], map: "idx_contest_token_buckets_contest")
  @@index([token_id], map: "idx_contest_token_buckets_token")
  @@map("contest_token_buckets")
}

model contest_token_performance {
  id             Int      @id @default(autoincrement())
  contest_id     Int
  wallet_address String   @db.VarChar(44)
  token_id       Int
  profit_loss    Decimal  @default(0) @db.Decimal(20, 8)
  timestamp      DateTime @default(now()) @db.Timestamptz(6)
  contests       contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens   @relation(fields: [token_id], references: [id])
  users          users    @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_token_performance")
}

model contest_token_prices {
  id             Int      @id @default(autoincrement())
  contest_id     Int
  wallet_address String   @db.VarChar(44)
  token_id       Int
  amount         Decimal  @default(0) @db.Decimal(20, 0)
  price          Decimal  @db.Decimal(20, 8)
  timestamp      DateTime @default(now()) @db.Timestamptz(6)
  contests       contests @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens   @relation(fields: [token_id], references: [id])
  users          users    @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_token_prices")
}

model contest_portfolio_trades {
  id             Int       @id @default(autoincrement())
  contest_id     Int
  wallet_address String    @db.VarChar(44)
  token_id       Int
  type           TradeType
  old_weight     Int
  new_weight     Int
  price_at_trade Decimal   @db.Decimal(20, 8)
  virtual_amount Decimal   @db.Decimal(20, 0)
  executed_at    DateTime  @default(now()) @db.Timestamptz(6)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  contests       contests  @relation(fields: [contest_id], references: [id], onDelete: Cascade)
  tokens         tokens    @relation(fields: [token_id], references: [id])
  users          users     @relation(fields: [wallet_address], references: [wallet_address])

  @@index([contest_id])
  @@index([wallet_address])
  @@index([token_id])
  @@map("contest_portfolio_trades")
}

model contests {
  id                        Int                         @id @default(autoincrement())
  contest_code              String                      @unique
  token_mint                String?                     @db.VarChar(44)
  name                      String
  description               String?
  image_url                 String?                     @db.VarChar(255)
  start_time                DateTime                    @db.Timestamptz(6)
  end_time                  DateTime                    @db.Timestamptz(6)
  entry_fee                 Decimal?                    @default(0) @db.Decimal(20, 8)
  prize_pool                Decimal                     @default(0) @db.Decimal(20, 8)
  current_prize_pool        Decimal                     @default(0) @db.Decimal(20, 8)
  status                    contest_status              @default(pending)
  settings                  Json?                       @default("{}")
  created_at                DateTime                    @default(now()) @db.Timestamptz(6)
  allowed_buckets           Int[]
  participant_count         Int                         @default(0)
  min_participants          Int                         @default(2)
  max_participants          Int?
  cancelled_at              DateTime?                   @db.Timestamptz(6)
  completed_at              DateTime?                   @db.Timestamptz(6)
  cancellation_reason       String?
  ai_decisions              ai_decisions[]
  blockchain_transactions   blockchain_transactions[]
  contest_participants      contest_participants[]
  contest_portfolio_trades  contest_portfolio_trades[]
  contest_portfolios        contest_portfolios[]
  contest_token_buckets     contest_token_buckets[]
  contest_token_performance contest_token_performance[]
  contest_token_prices      contest_token_prices[]
  contest_wallets           contest_wallets?
  transactions              transactions[]
  vanity_wallet             vanity_wallet_pool?
  schedule                  contest_schedule?           @relation(fields: [schedule_id], references: [id])
  schedule_id               Int?

  @@index([status])
  @@index([start_time])
  @@index([end_time])
  @@map("contests")
}

model token_bucket_memberships {
  bucket_id     Int
  token_id      Int
  token_buckets token_buckets @relation(fields: [bucket_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens        tokens        @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([bucket_id, token_id])
  @@index([token_id], map: "idx_token_bucket_memberships_token")
  @@map("token_bucket_memberships")
}

model token_buckets {
  id                       Int                        @id @default(autoincrement())
  bucket_code              String                     @unique(map: "unique_token_bucket_code")
  name                     String
  description              String?
  created_at               DateTime?                  @default(now()) @db.Timestamptz(6)
  token_bucket_memberships token_bucket_memberships[]

  @@index([bucket_code], map: "idx_token_buckets_code")
  @@map("token_buckets")
}

model token_prices {
  token_id   Int       @id
  price      Decimal?  @db.Decimal(20, 8)
  change_24h Decimal?  @db.Decimal(10, 2)
  market_cap Decimal?  @db.Decimal(20, 0)
  volume_24h Decimal?  @db.Decimal(20, 0)
  liquidity  Decimal?  @db.Decimal(20, 0)
  fdv        Decimal?  @db.Decimal(20, 0)
  updated_at DateTime? @default(now()) @db.Timestamptz(6)
  tokens     tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([updated_at(sort: Desc)], map: "idx_token_prices_updated")
  @@map("token_prices")
}

model token_price_history {
  id         Int      @id @default(autoincrement())
  token_id   Int
  price      Decimal  @db.Decimal(20, 8)
  source     String?  @db.VarChar(50) // Where the price came from: "jupiter", "helius", "manual", etc.
  timestamp  DateTime @default(now()) @db.Timestamptz(6)
  tokens     tokens   @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@map("token_price_history")
}

model tokens {
  id                        Int                         @id @default(autoincrement())
  address                   String                      @unique(map: "unique_token_address")
  symbol                    String?                     
  name                      String?                     
  decimals                  Int?                        @default(9)
  is_active                 Boolean                     @default(true)
  created_at                DateTime?                   @default(now()) @db.Timestamptz(6)
  updated_at                DateTime?                   @default(now()) @db.Timestamptz(6)
  image_url                 String?                     @db.VarChar(255)
  color                     String?                     @default("#888888")
  description               String?
  twitter_url               String?                     @db.VarChar(255)
  telegram_url              String?                     @db.VarChar(255)
  discord_url               String?                     @db.VarChar(255)
  website_url               String?                     @db.VarChar(255)
  coingeckoId               String?                     // Coingecko ID for this token 
  tags                      Json?                       // Tags from Jupiter stored as JSON
  raw_supply                BigInt?                     // Total supply in smallest units (raw from blockchain)
  total_supply              Decimal?                    @db.Decimal(38, 18) // Normalized supply with decimals applied
  refresh_interval_seconds  Int                         @default(30) // Default refresh every 30 seconds
  priority_score            Int                         @default(0) // Higher score = higher priority for refreshing
  last_refresh_attempt      DateTime?                   // When refresh was last attempted
  last_refresh_success      DateTime?                   // When refresh last succeeded
  last_price_change         DateTime?                   // When price last changed
  refresh_metadata          Json?                       @default("{}")  // Additional metadata for refresh scheduler
  ai_decisions              ai_decisions[]
  contest_portfolio_trades  contest_portfolio_trades[]
  contest_portfolios        contest_portfolios[]
  contest_token_buckets     contest_token_buckets[]
  contest_token_performance contest_token_performance[]
  contest_token_prices      contest_token_prices[]
  token_bucket_memberships  token_bucket_memberships[]
  token_prices              token_prices?
  token_socials             token_socials[]
  token_websites            token_websites[]
  price_history             token_price_history[]
  rank_history              token_rank_history[]
  volume_history            token_volume_history[]
  liquidity_history         token_liquidity_history[]
  market_cap_history        token_market_cap_history[]
  pools                     token_pools[]               // DEX pools relation
  monitored_tokens          monitored_tokens?           // Monitoring relation for Discord alerts
  pool_price_changes        pool_price_changes[]        // Real-time price changes from pool monitoring

  @@index([symbol], map: "idx_tokens_symbol")
  @@map("tokens")
}

model transactions {
  id                                                                           Int                    @id @default(autoincrement())
  wallet_address                                                               String?
  type                                                                         transaction_type
  amount                                                                       Decimal                @db.Decimal(20, 8)
  balance_before                                                               Decimal                @db.Decimal(20, 8)
  balance_after                                                                Decimal                @db.Decimal(20, 8)
  contest_id                                                                   Int?
  description                                                                  String?
  status                                                                       transaction_status?    @default(completed)
  metadata                                                                     Json?                  @default("{}")
  created_at                                                                   DateTime?              @default(now()) @db.Timestamptz(6)
  processed_at                                                                 DateTime?              @db.Timestamptz(6)
  contest_participants_contest_participants_entry_transaction_idTotransactions contest_participants[] @relation("contest_participants_entry_transaction_idTotransactions")
  contest_participants_contest_participants_prize_transaction_idTotransactions contest_participants[] @relation("contest_participants_prize_transaction_idTotransactions")
  referral_rewards                                                             referral_rewards[]
  contests                                                                     contests?              @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  users                                                                        users?                 @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([contest_id], map: "idx_transactions_contest")
  @@index([type, created_at], map: "idx_transactions_type_created")
  @@index([wallet_address], map: "idx_transactions_wallet")
  @@map("transactions")
}

model user_achievements {
  id               Int       @id @default(autoincrement())
  wallet_address   String?
  achievement_type String
  value            Json?     @default("{}")
  achieved_at      DateTime? @default(now()) @db.Timestamptz(6)
  tier             String    @default("BRONZE") @db.VarChar(20)
  category         String    @default("CONTESTS") @db.VarChar(20)
  xp_awarded       Int       @default(0)
  context          Json?     @default("{}")
  user             users?    @relation(fields: [wallet_address], references: [wallet_address], onUpdate: NoAction)

  @@index([wallet_address], map: "idx_user_achievements_wallet")
  @@index([achievement_type], map: "idx_user_achievements_type")
  @@index([category], map: "idx_user_achievements_category")
  @@index([tier], map: "idx_user_achievements_tier")
  @@map("user_achievements")
}

model user_social_profiles {
  wallet_address    String
  platform          String
  platform_user_id  String
  username          String
  verified          Boolean?  @default(false)
  verification_date DateTime? @db.Timestamptz(6)
  last_verified     DateTime? @db.Timestamptz(6)
  metadata          Json?     @default("{}")
  created_at        DateTime? @default(now()) @db.Timestamptz(6)
  updated_at        DateTime? @default(now()) @db.Timestamptz(6)
  user              users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade, onUpdate: Cascade)

  @@id([wallet_address, platform])
  @@unique([platform, platform_user_id], map: "unique_platform_user")
  @@index([platform, platform_user_id], map: "idx_user_social_profiles_platform")
  @@map("user_social_profiles")
}

model user_stats {
  wallet_address    String    @id
  contests_entered  Int?      @default(0)
  contests_won      Int?      @default(0)
  total_prize_money Decimal?  @default(0) @db.Decimal(20, 0)
  best_score        Decimal?  @db.Decimal(10, 2)
  avg_score         Decimal?  @db.Decimal(10, 2)
  last_updated      DateTime? @default(now()) @db.Timestamptz(6)
  users             users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address], map: "idx_user_stats_wallet")
  @@map("user_stats")
}

model user_token_stats {
  wallet_address       String
  token_address        String
  times_picked         Int?     @default(0)
  wins_with_token      Int?     @default(0)
  avg_score_with_token Decimal? @db.Decimal(10, 2)

  @@id([wallet_address, token_address])
  @@index([wallet_address], map: "idx_user_token_stats_wallet")
  @@index([token_address], map: "idx_user_token_stats_token")
  @@map("user_token_stats")
}

model users {
  id                        Int                         @id @default(autoincrement())
  wallet_address            String                      @unique
  username                  String?                     @unique
  email                     String?                     @unique
  nickname                  String?
  role                      UserRole                    @default(user)
  user_level_id             Int?
  created_at                DateTime?                   @default(now()) @db.Timestamptz(6)
  updated_at                DateTime?                   @db.Timestamptz(6)
  last_login                DateTime?                   @db.Timestamptz(6)
  total_contests            Int?                        @default(0)
  is_banned                 Boolean                     @default(false)
  ban_reason                String?
  referral_code             String?                     @unique @db.VarChar(20)
  referred_by_code          String?                     @db.VarChar(20)
  experience_points         Int                         @default(0)
  last_level_up             DateTime?                   @db.Timestamptz(6)
  profile_image_url         String?                     @db.VarChar(255)
  profile_image_updated_at  DateTime?                   @db.Timestamptz(6)
  last_balance_check        DateTime?                   @db.Timestamptz(6)
  last_known_balance        BigInt?
  contest_participants      contest_participants[]
  contest_portfolio_trades  contest_portfolio_trades[]
  contest_portfolios        contest_portfolios[]
  contest_token_performance contest_token_performance[]
  contest_token_prices      contest_token_prices[]
  ip_history                user_ip_history[]
  participant_influences    participant_influences[]
  referral_clicks           referral_clicks[]           @relation("ReferralClicksReceived")
  referral_milestones       referral_milestones[]
  referral_rankings         referral_period_rankings[]
  referral_rewards          referral_rewards[]
  referred_by               referrals[]                 @relation("ReferredByRelation")
  referrals_made            referrals[]                 @relation("ReferralsMadeRelation")
  social_profiles           user_social_profiles[]
  transactions              transactions[]
  user_achievements         user_achievements[]
  user_stats                user_stats?
  user_level                user_levels?                @relation(fields: [user_level_id], references: [id])
  wallet_balances           wallet_balance_history[]
  websocket_messages        websocket_messages[]
  authorized_devices        authorized_devices[]        @relation(name: "UserAuthorizedDevices")
  ai_conversations          ai_conversations[]          @relation("UserAIConversations")
  client_errors             client_errors[]
  biometric_credentials     biometric_credentials[]

  @@index([wallet_address], map: "idx_users_wallet")
  @@index([username], map: "idx_users_username")
  @@index([role], map: "idx_users_role")
  @@index([experience_points(sort: Desc)], map: "idx_users_experience_points")
  @@map("users")
}

model admin_logs {
  id            Int      @id @default(autoincrement())
  admin_address String   @db.VarChar
  action        String   @db.VarChar
  details       Json     @default("{}")
  created_at    DateTime @default(now()) @db.Timestamptz(6)
  ip_address    String?  @db.VarChar
  user_agent    String?  @db.VarChar

  @@index([admin_address], map: "idx_admin_logs_admin")
  @@index([created_at], map: "idx_admin_logs_created")
  @@map("admin_logs")
}

model ai_agents {
  id             Int            @id @default(autoincrement())
  name           String         @db.VarChar
  personality    String         @db.VarChar
  risk_tolerance Int
  expertise      String[]       @db.VarChar
  created_at     DateTime       @default(now()) @db.Timestamptz(6)
  is_active      Boolean        @default(true)
  ai_decisions   ai_decisions[]

  @@map("ai_agents")
}

model ai_decisions {
  id                     Int                      @id @default(autoincrement())
  agent_id               Int
  contest_id             Int
  decision_type          AIDecisionType
  token_id               Int
  amount                 Decimal                  @db.Decimal(20, 0)
  reasoning              String                   @db.VarChar
  market_context         Json?                    @default("{}")
  external_factors       Json?                    @default("{}")
  timestamp              DateTime                 @default(now()) @db.Timestamptz(6)
  success_score          Int?
  price_impact           Decimal?                 @db.Decimal(10, 2)
  ai_agents              ai_agents                @relation(fields: [agent_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  contests               contests                 @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tokens                 tokens                   @relation(fields: [token_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  participant_influences participant_influences[]

  @@index([contest_id, timestamp], map: "idx_ai_decisions_contest_time")
  @@index([token_id, timestamp], map: "idx_ai_decisions_token_time")
  @@map("ai_decisions")
}

model auth_challenges {
  wallet_address String    @id
  nonce          String
  expires_at     DateTime  @db.Timestamptz(6)
  created_at     DateTime? @default(now()) @db.Timestamptz(6)
  credential_id  String?   // Added for biometric auth challenges

  @@index([expires_at], map: "idx_auth_challenges_expires")
  @@map("auth_challenges")
}

model biometric_credentials {
  id            Int       @id @default(autoincrement())
  user_id       String    @db.VarChar(44)
  credential_id String    @unique
  public_key    String
  device_info   Json?     @default("{}")
  created_at    DateTime  @default(now()) @db.Timestamptz(6)
  last_used     DateTime? @db.Timestamptz(6)
  counter       BigInt    @default(0)
  user          users     @relation(fields: [user_id], references: [wallet_address], onDelete: Cascade)

  @@index([user_id], map: "idx_biometric_credentials_user")
  @@map("biometric_credentials")
}

model blockchain_transactions {
  id           Int                @id @default(autoincrement())
  tx_hash      String             @unique @db.VarChar
  wallet_from  String             @db.VarChar
  wallet_to    String             @db.VarChar
  amount       Decimal            @db.Decimal(20, 8)
  token_type   TokenType          @default(SOL)
  chain        Chain              @default(SOLANA)
  status       transaction_status @default(pending)
  type         transaction_type
  contest_id   Int?
  created_at   DateTime           @default(now()) @db.Timestamptz(6)
  confirmed_at DateTime?          @db.Timestamptz(6)
  error        String?            @db.VarChar
  signature    String?            @db.VarChar
  slot         Int?
  contests     contests?          @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([contest_id], map: "idx_blockchain_transactions_contest")
  @@index([signature], map: "idx_blockchain_transactions_signature")
  @@index([tx_hash], map: "idx_blockchain_transactions_hash")
  @@index([wallet_from, wallet_to], map: "idx_blockchain_transactions_wallets")
  @@map("blockchain_transactions")
}

model contest_wallets {
  id             Int       @id @default(autoincrement())
  contest_id     Int       @unique
  wallet_address String    @db.VarChar
  private_key    String    @db.VarChar
  balance        Decimal   @db.Decimal(20, 8)
  is_vanity      Boolean   @default(false)
  vanity_type    String?   @db.VarChar
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime? @db.Timestamptz(6)
  last_sync      DateTime? @db.Timestamptz(6)
  contests       contests  @relation(fields: [contest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address], map: "idx_contest_wallets_wallet")
  @@map("contest_wallets")
}

model seed_wallets {
  wallet_address String   @id
  private_key    String
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
  is_active      Boolean  @default(true)
  purpose        String?
  metadata       Json?
}

model banned_ips {
  id           Int       @id @default(autoincrement())
  ip_address   String    @unique
  reason       String
  is_permanent Boolean   @default(false)
  expires_at   DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)
  created_by   String    @db.VarChar(44)
  updated_at   DateTime? @updatedAt @db.Timestamptz(6)
  num_attempts Int       @default(0)
  troll_level  Int       @default(1)
  metadata     Json?     @default("{}")

  @@index([ip_address], map: "idx_banned_ips_address")
  @@index([expires_at], map: "idx_banned_ips_expires")
  @@map("banned_ips")
}

model user_ip_history {
  id            Int       @id @default(autoincrement())
  wallet_address String    @db.VarChar(44)
  ip_address     String    @db.VarChar(45) // IPv6 can be longer
  user_agent     String?   @db.Text
  first_seen     DateTime  @default(now()) @db.Timestamptz(6)
  last_seen      DateTime  @default(now()) @db.Timestamptz(6)
  access_count   Int       @default(1)
  country_code   String?   @db.VarChar(2)
  region         String?   @db.VarChar(100)
  city           String?   @db.VarChar(100)
  is_suspicious  Boolean   @default(false)
  notes          String?   @db.Text
  metadata       Json?     @default("{}")
  users          users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@unique([wallet_address, ip_address], name: "user_ip_unique")
  @@index([ip_address], map: "idx_user_ip_address")
  @@index([wallet_address], map: "idx_user_ip_wallet")
  @@index([is_suspicious], map: "idx_user_ip_suspicious")
  @@index([first_seen], map: "idx_user_ip_first_seen")
  @@index([last_seen], map: "idx_user_ip_last_seen")
  @@map("user_ip_history")
}

model participant_influences {
  id                  Int          @id @default(autoincrement())
  decision_id         Int
  wallet_address      String       @db.VarChar
  persuasion_score    Int
  contribution_weight Decimal      @db.Decimal(5, 2)
  timestamp           DateTime     @default(now()) @db.Timestamptz(6)
  ai_decisions        ai_decisions @relation(fields: [decision_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  users               users        @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address, decision_id], map: "idx_participant_influences_lookup")
  @@map("participant_influences")
}

model system_settings {
  key         String   @id @map("key")
  value       Json
  description String?
  updated_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_by  String?  @db.VarChar(44)

  @@map("system_settings")
}

model service_configuration {
  id                 String    @id @default(cuid())
  service_name       String    @unique // Unique service identifier
  display_name       String    // Human-readable name
  
  // Core configuration
  enabled            Boolean   @default(true)
  check_interval_ms  Int       @default(60000) // How often the service runs
  
  // Optional advanced configuration (stored as JSON for flexibility)
  circuit_breaker    Json?     // Circuit breaker settings
  backoff            Json?     // Backoff settings
  thresholds         Json?     // Various thresholds
  
  // Metadata
  last_updated       DateTime  @default(now()) @updatedAt
  updated_by         String?   // Admin who made the change
  
  // Service status tracking (read-only fields updated by the service)
  last_run_at        DateTime?
  last_run_duration_ms Int?
  last_status        String?   // 'success', 'failure', 'degraded'
  status_message     String?

  @@map("service_configuration")
}

model achievement_categories {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(50)
  description String?
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  @@map("achievement_categories")
}

model achievement_tiers {
  id         Int      @id @default(autoincrement())
  name       String   @db.VarChar(20)
  color_hex  String   @db.VarChar(7)
  points     Int
  created_at DateTime @default(now()) @db.Timestamptz(6)

  @@map("achievement_tiers")
}

model user_levels {
  id                             Int      @id @default(autoincrement())
  level_number                   Int
  class_name                     String   @db.VarChar(20)
  title                          String   @db.VarChar(50)
  min_exp                        Int
  bronze_achievements_required   Int
  silver_achievements_required   Int
  gold_achievements_required     Int
  platinum_achievements_required Int
  diamond_achievements_required  Int
  icon_url                       String?  @db.VarChar(255)
  created_at                     DateTime @default(now()) @db.Timestamptz(6)
  users                          users[]

  @@map("user_levels")
}

model achievement_tier_requirements {
  id                Int      @id @default(autoincrement())
  achievement_type  String
  tier_id           Int
  requirement_value Json
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  @@index([achievement_type, tier_id], map: "idx_achievement_tier_requirements_lookup")
  @@map("achievement_tier_requirements")
}

model level_rewards {
  id           Int      @id @default(autoincrement())
  level_id     Int
  reward_type  String   @db.VarChar(50)
  reward_value Json
  created_at   DateTime @default(now()) @db.Timestamptz(6)

  @@map("level_rewards")
}

model websocket_messages {
  id             Int       @id @default(autoincrement())
  type           String
  data           Json
  wallet_address String
  timestamp      DateTime  @default(now()) @db.Timestamptz(6)
  delivered      Boolean   @default(false)
  delivered_at   DateTime? @db.Timestamptz(6)
  read           Boolean   @default(false)
  read_at        DateTime? @db.Timestamptz(6)
  users          users     @relation(fields: [wallet_address], references: [wallet_address], onDelete: NoAction, onUpdate: NoAction)

  @@index([wallet_address, type], map: "idx_websocket_messages_wallet_type")
  @@index([timestamp], map: "idx_websocket_messages_timestamp")
  @@index([delivered_at], map: "idx_websocket_messages_delivered_at")
  @@index([read, wallet_address], map: "idx_websocket_messages_read_wallet")
  @@map("websocket_messages")
}

model vanity_wallet_pool {
  id              Int               @id @default(autoincrement())
  wallet_address  String?           @unique // Null until address is generated
  private_key     String?           // Encrypted private key, null until generated
  pattern         String            // The pattern to match (e.g., "DUEL" or "DEGEN")
  is_suffix       Boolean           @default(false) // Whether pattern should be at end of address
  case_sensitive  Boolean           @default(true)  // Whether pattern matching is case sensitive
  is_used         Boolean           @default(false) // Whether this vanity address has been assigned
  used_at         DateTime?         // When the vanity address was assigned 
  used_by_contest Int?              @unique         // The contest using this vanity address
  job_id          String?           @unique         // External GPU job ID
  status          VanityWalletStatus @default(pending) // Status of the generation request
  attempts        BigInt?           // Number of attempts made to find this address
  duration_ms     BigInt?           // Time taken to generate in milliseconds
  requested_by    String?           // Admin who requested this wallet
  request_ip      String?           // IP address that requested this wallet
  callback_url    String?           // URL for job completion callback
  created_at      DateTime          @default(now())
  updated_at      DateTime          @updatedAt
  completed_at    DateTime?         // When the address generation was completed
  contest         contests?         @relation(fields: [used_by_contest], references: [id])

  @@index([is_used])
  @@index([pattern])
  @@index([status])
  @@index([job_id])
}

enum VanityWalletStatus {
  pending     // Just created, not yet sent to GPU service
  processing  // Sent to GPU service, awaiting result
  completed   // Successfully generated
  failed      // Failed to generate
  cancelled   // Request was cancelled
}

model referrals {
  id              Int            @id @default(autoincrement())
  referrer_id     String         @db.VarChar(44)
  referred_id     String         @db.VarChar(44)
  referral_code   String         @db.VarChar(20)
  status          ReferralStatus @default(pending)
  source          String?
  landing_page    String?
  utm_source      String?
  utm_medium      String?
  utm_campaign    String?
  device          String?
  browser         String?
  ip_address      String?
  user_agent      String?
  session_id      String?
  click_timestamp DateTime?      @db.Timestamptz(6)
  reward_amount   Decimal?       @db.Decimal(20, 0)
  reward_paid_at  DateTime?      @db.Timestamptz(6)
  qualified_at    DateTime?      @db.Timestamptz(6)
  created_at      DateTime       @default(now()) @db.Timestamptz(6)
  referred        users          @relation("ReferredByRelation", fields: [referred_id], references: [wallet_address], onDelete: Cascade)
  referrer        users          @relation("ReferralsMadeRelation", fields: [referrer_id], references: [wallet_address], onDelete: Cascade)

  @@index([referrer_id])
  @@index([referred_id])
  @@index([referral_code])
  @@index([status])
}

model referral_clicks {
  id            Int       @id @default(autoincrement())
  referral_code String    @db.VarChar(20)
  referrer_id   String    @db.VarChar(44)
  source        String?
  landing_page  String?
  utm_source    String?
  utm_medium    String?
  utm_campaign  String?
  device        String?
  browser       String?
  ip_address    String
  user_agent    String?
  session_id    String
  converted     Boolean   @default(false)
  converted_at  DateTime? @db.Timestamptz(6)
  timestamp     DateTime  @default(now()) @db.Timestamptz(6)
  referrer      users     @relation("ReferralClicksReceived", fields: [referrer_id], references: [wallet_address], onDelete: Cascade)

  @@index([referral_code])
  @@index([referrer_id])
  @@index([session_id])
  @@index([ip_address])
}

model referral_rewards {
  id             Int                @id @default(autoincrement())
  wallet_address String             @db.VarChar(44)
  reward_type    ReferralRewardType
  amount         Decimal            @db.Decimal(20, 0)
  description    String?
  transaction_id Int?
  created_at     DateTime           @default(now()) @db.Timestamptz(6)
  paid_at        DateTime?          @db.Timestamptz(6)
  transaction    transactions?      @relation(fields: [transaction_id], references: [id])
  users          users              @relation(fields: [wallet_address], references: [wallet_address])

  @@index([wallet_address])
  @@index([created_at])
  @@map("referral_rewards")
}

model managed_wallets {
  id                    String   @id @default(uuid())
  public_key            String   @unique @db.VarChar(44)
  encrypted_private_key String
  label                 String?  @db.VarChar(255)
  status                String   @default("active") @db.VarChar(20)
  metadata              Json?    @default("{}")
  created_at            DateTime @default(now()) @db.Timestamptz(6)
  updated_at            DateTime @updatedAt @db.Timestamptz(6)

  @@map("managed_wallets")
}

model referral_periods {
  id         Int                        @id @default(autoincrement())
  start_date DateTime                   @db.Timestamptz(6)
  end_date   DateTime                   @db.Timestamptz(6)
  is_active  Boolean                    @default(true)
  status     String                     @default("in_progress")
  created_at DateTime                   @default(now()) @db.Timestamptz(6)
  updated_at DateTime                   @default(now()) @db.Timestamptz(6)
  rankings   referral_period_rankings[]
}

model referral_period_rankings {
  id             Int              @id @default(autoincrement())
  period_id      Int
  user_id        String           @db.VarChar(44)
  referral_count Int              @default(0)
  rank           Int
  trend          String           @default("stable")
  reward_amount  Decimal?         @db.Decimal(20, 0)
  status         String           @default("pending")
  created_at     DateTime         @default(now()) @db.Timestamptz(6)
  updated_at     DateTime         @default(now()) @db.Timestamptz(6)
  period         referral_periods @relation(fields: [period_id], references: [id], onDelete: Cascade)
  user           users            @relation(fields: [user_id], references: [wallet_address], onDelete: Cascade)

  @@unique([period_id, user_id])
  @@index([period_id])
  @@index([user_id])
}

model referral_milestones {
  id              Int      @id @default(autoincrement())
  user_id         String   @db.VarChar(44)
  milestone_level Int
  referral_count  Int
  reward_amount   Decimal  @db.Decimal(20, 0)
  status          String   @default("pending")
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @db.Timestamptz(6)
  user            users    @relation(fields: [user_id], references: [wallet_address], onDelete: Cascade)

  @@unique([user_id, milestone_level])
  @@index([user_id])
}

model wallet_balance_history {
  id               Int      @id @default(autoincrement())
  wallet_address   String   @db.VarChar(44)
  balance_lamports BigInt
  timestamp        DateTime @default(now()) @db.Timestamptz(6)
  users            users    @relation(fields: [wallet_address], references: [wallet_address], onDelete: Cascade)

  @@index([wallet_address], map: "idx_wallet_balance_wallet")
  @@index([timestamp], map: "idx_wallet_balance_timestamp")
  @@map("wallet_balance_history")
}

model circuit_breaker_states {
  id                Int                         @id @default(autoincrement())
  service_name      String                      @unique
  state             String                      @default("closed")
  failure_count     Int                         @default(0)
  last_failure      DateTime?
  recovery_attempts Int                         @default(0)
  updated_at        DateTime                    @updatedAt
  config            circuit_breaker_config?
  incidents         circuit_breaker_incidents[]

  @@index([state])
  @@map("circuit_breaker_states")
}

model circuit_breaker_incidents {
  id           String                 @id @default(uuid())
  service_name String
  type         String
  severity     String
  status       String                 @default("active")
  message      String
  start_time   DateTime               @default(now())
  end_time     DateTime?
  metrics      Json?
  state        circuit_breaker_states @relation(fields: [service_name], references: [service_name])

  @@index([service_name, status])
  @@index([start_time])
  @@map("circuit_breaker_incidents")
}

model circuit_breaker_config {
  service_name      String                 @id
  failure_threshold Int                    @default(5)
  recovery_timeout  Int                    @default(30000)
  request_limit     Int                    @default(100)
  monitoring_window Int                    @default(60000)
  minimum_requests  Int                    @default(10)
  updated_at        DateTime               @updatedAt
  state             circuit_breaker_states @relation(fields: [service_name], references: [service_name])

  @@map("circuit_breaker_config")
}

model authorized_devices {
  id            Int      @id @default(autoincrement())
  wallet_address String   @db.Text
  device_id      String   @db.Text
  device_name    String?  @db.Text
  device_type    String?  @db.Text
  last_used      DateTime @default(now()) @db.Timestamptz(6)
  created_at     DateTime @default(now()) @db.Timestamptz(6)
  is_active      Boolean  @default(true)
  
  user           users    @relation(fields: [wallet_address], references: [wallet_address], name: "UserAuthorizedDevices", onDelete: Cascade, onUpdate: Cascade)

  @@unique([wallet_address, device_id], name: "authorized_devices_wallet_address_device_id_key")
  @@index([wallet_address], name: "idx_authorized_devices_wallet")
  @@index([device_id], name: "idx_authorized_devices_device_id")
  @@map("authorized_devices")
}

enum UserRole {
  user
  admin
  superadmin
}

enum contest_status {
  pending
  active
  completed
  cancelled
}

enum transaction_status {
  pending
  completed
  failed
  reversed
}

enum transaction_type {
  CONTEST_ENTRY
  PRIZE_PAYOUT
  DEPOSIT
  WITHDRAWAL
  REFERRAL_BONUS
  PROMOTION
}

enum AIDecisionType {
  BUY
  SELL
  HOLD
  SPECIAL_EVENT
}

enum Chain {
  SOLANA
  ETHEREUM
  BSC
}

enum TokenType {
  SOL
  DUEL
  SPL
}

enum TradeType {
  BUY
  SELL
  SHORT
  CLOSE_SHORT
}

enum ReferralStatus {
  pending
  qualified
  rewarded
  expired
}

enum ReferralRewardType {
  signup_bonus
  contest_bonus
  special_event
}

model token_socials {
  id         Int       @id @default(autoincrement())
  token_id   Int
  type       String
  url        String
  created_at DateTime? @default(now())
  token      tokens    @relation(fields: [token_id], references: [id])

  @@index([token_id])
  @@map("token_socials")
}

model token_websites {
  id         Int       @id @default(autoincrement())
  token_id   Int
  label      String?
  url        String
  created_at DateTime? @default(now())
  token      tokens    @relation(fields: [token_id], references: [id])

  @@index([token_id])
  @@map("token_websites")
}

model ai_conversations {
  id                 String    @id @default(uuid())
  wallet_address     String    @db.VarChar(44)
  conversation_id    String    @unique
  context            String?   @db.VarChar(50)
  message_count      Int       @default(0)
  total_tokens_used  Int       @default(0)
  first_message_at   DateTime  @default(now()) @db.Timestamptz(6)
  last_message_at    DateTime  @default(now()) @db.Timestamptz(6)
  is_active          Boolean   @default(true)
  metadata           Json?     @default("{}")
  user               users     @relation("UserAIConversations", fields: [wallet_address], references: [wallet_address], onDelete: Cascade)
  messages           ai_conversation_messages[]

  @@index([wallet_address])
  @@index([conversation_id])
  @@index([last_message_at])
  @@map("ai_conversations")
}

model ai_conversation_messages {
  id                 String          @id @default(uuid())
  conversation_id    String
  role               String          @db.VarChar(20)
  content            String          @db.Text
  tokens             Int?
  created_at         DateTime        @default(now()) @db.Timestamptz(6)
  conversation       ai_conversations @relation(fields: [conversation_id], references: [conversation_id], onDelete: Cascade)

  @@index([conversation_id])
  @@index([created_at])
  @@map("ai_conversation_messages")
}

// AI analysis for client errors
model ai_error_analyses {
  id                      Int                @id @default(autoincrement())
  summary                 String             @db.Text
  analyzed_at             DateTime           @default(now()) @db.Timestamptz(6)
  error_count             Int
  time_window_minutes     Int
  severity_distribution   Json?              @default("{}")
  browser_distribution    Json?              @default("{}")
  os_distribution         Json?              @default("{}")
  top_errors              Json?              @default("[]")
  created_by              String?            @db.VarChar(44)
  analyzed_errors         ai_analyzed_errors[]
  
  // AI model and cost tracking
  model_used              String?            @db.VarChar(50) // The AI model used (e.g., "gpt-4", "claude-3-opus")
  tokens_used             Int?               // Total tokens used for this analysis
  tokens_prompt           Int?               // Tokens used in the prompt
  tokens_completion       Int?               // Tokens used in the completion/response
  estimated_cost_usd      Float?             // Estimated cost in USD

  // New extension fields
  actionability_score     Int?               // 1-10 score indicating how actionable the insights are
  issue_categories        Json?              @default("[]") // Array of issue categories (routing, auth, ui, etc.)
  recommended_actions     Json?              @default("[]") // Structured list of recommended actions
  resolution_status       String?            @db.VarChar(20) // "pending", "in_progress", "resolved", "wont_fix"
  assigned_to             String?            @db.VarChar(44) // Wallet address of user assigned to fix
  priority                Int?               // 1-5 scale where 5 is highest priority
  estimated_impact        String?            @db.VarChar(50) // User impact description (e.g., "10% of admin users")
  related_services        Json?              @default("[]") // List of related services affected

  @@index([analyzed_at])
  @@index([resolution_status])
  @@index([assigned_to])
  @@map("ai_error_analyses")
}

// Junction table to track which errors have been analyzed
model ai_analyzed_errors {
  id              Int                @id @default(autoincrement())
  error_id        String             // References client_errors.error_id
  analysis_id     Int                
  analyzed_at     DateTime           @default(now()) @db.Timestamptz(6)
  analysis        ai_error_analyses  @relation(fields: [analysis_id], references: [id], onDelete: Cascade)
  
  @@unique([error_id, analysis_id])
  @@index([error_id])
  @@index([analysis_id])
  @@map("ai_analyzed_errors")
}

// AI analysis for admin actions
model ai_admin_action_analyses {
  id                     Int                       @id @default(autoincrement())
  summary                String                    @db.Text
  analyzed_at            DateTime                  @default(now()) @db.Timestamptz(6)
  action_count           Int
  time_window_minutes    Int
  action_distribution    Json?                     @default("{}")
  admin_distribution     Json?                     @default("{}")
  top_actions            Json?                     @default("[]")
  analyzed_actions       ai_analyzed_admin_actions[]
  created_by             String?                   @db.VarChar(44)

  @@index([analyzed_at])
  @@map("ai_admin_action_analyses")
}

// Junction table to track which admin actions have been analyzed
model ai_analyzed_admin_actions {
  id              Int                       @id @default(autoincrement())
  action_id       Int                       // References admin_logs.id
  analysis_id     Int                
  analyzed_at     DateTime                  @default(now()) @db.Timestamptz(6)
  analysis        ai_admin_action_analyses  @relation(fields: [analysis_id], references: [id], onDelete: Cascade)
  
  @@unique([action_id, analysis_id])
  @@index([action_id])
  @@index([analysis_id])
  @@map("ai_analyzed_admin_actions")
}

model ai_log_analyses {
  id                     Int       @id @default(autoincrement())
  summary                String    @db.Text
  analyzed_at            DateTime  @default(now()) @db.Timestamptz(6)
  log_file               String    @db.VarChar(255)
  lines_analyzed         Int
  created_by             String?   @db.VarChar(44)

  @@index([analyzed_at])
  @@map("ai_log_analyses")
}

model ai_service_log_analyses {
  id                     Int                        @id @default(autoincrement())
  service                String                     @db.VarChar(50)
  summary                String                     @db.Text
  analyzed_at            DateTime                   @default(now()) @db.Timestamptz(6)
  log_count              Int
  time_window_hours      Int
  created_by             String?                    @db.VarChar(44)
  analyzed_logs          ai_analyzed_service_logs[]
  
  // New extension fields
  performance_score      Int?                       // 1-10 score where 10 is excellent performance
  health_status          String?                    @db.VarChar(20) // "healthy", "degraded", "failing", "unknown"
  log_patterns           Json?                      @default("[]")  // Array of detected log patterns
  anomalies_detected     Json?                      @default("[]")  // Array of anomalies detected in logs
  common_operations      Json?                      @default("[]")  // Most common operations in logs
  operation_frequency    Json?                      @default("{}")  // Frequency of different operations
  operation_success_rate Json?                      @default("{}")  // Success rate by operation type
  performance_metrics    Json?                      @default("{}")  // Performance metrics extracted from logs
  service_dependencies   Json?                      @default("[]")  // Other services this service depends on
  recommendations        Json?                      @default("[]")  // AI recommendations for service improvement

  @@index([analyzed_at])
  @@index([service])
  @@index([health_status])
  @@map("ai_service_log_analyses")
}

model ai_analyzed_service_logs {
  id              Int                      @id @default(autoincrement())
  log_id          Int                      // References service_logs.id
  service         String                   @db.VarChar(50)
  analysis_id     Int                
  analyzed_at     DateTime                 @default(now()) @db.Timestamptz(6)
  analysis        ai_service_log_analyses  @relation(fields: [analysis_id], references: [id], onDelete: Cascade)
  
  @@unique([log_id, analysis_id])
  @@index([log_id])
  @@index([analysis_id])
  @@index([service])
  @@map("ai_analyzed_service_logs")
}

// Service logs for tracking service-specific events and states
model service_logs {
  id                 Int       @id @default(autoincrement())
  service            String    @db.VarChar(50) // Service identifier (e.g., 'solana_engine', 'token_refresh')
  level              String    @db.VarChar(20) // Log level (info, warn, error, debug)
  message            String    @db.Text // The log message
  details            Json?     @default("{}") // Additional structured details
  metadata           Json?     @default("{}") // Extra context data
  instance_id        String?   @db.VarChar(100) // For multi-instance services
  created_at         DateTime  @default(now()) @db.Timestamptz(6)
  related_entity     String?   @db.VarChar(100) // Related entity (token address, contest ID, etc.)
  event_type         String?   @db.VarChar(50) // Type of event (restart, health check, etc.)
  duration_ms        Int?      // For performance tracking
  environment        String?   @db.VarChar(20) // Production, staging, etc.
  
  @@index([service, level])
  @@index([created_at])
  @@index([service, created_at])
  @@index([level, created_at])
  @@index([related_entity])
  @@index([event_type])
  @@map("service_logs")
}

model websocket_connections {
  id                 Int       @id @default(autoincrement())
  connection_id      String    // Unique session identifier for the WebSocket connection
  ip_address         String    @db.VarChar(45) // IPv6 can be longer
  user_agent         String?   @db.Text
  wallet_address     String?   @db.VarChar(44)
  nickname           String?   @db.VarChar(100)
  is_authenticated   Boolean   @default(false)
  environment        String?   @db.VarChar(20) // 'production', 'development', etc.
  origin             String?   @db.Text
  connected_at       DateTime  @default(now()) @db.Timestamptz(6)
  disconnected_at    DateTime? @db.Timestamptz(6)
  duration_seconds   Int?
  close_code         Int?
  close_reason       String?   @db.Text
  subscribed_topics  Json?     @default("[]")
  messages_received  Int       @default(0)
  messages_sent      Int       @default(0)
  connection_error   String?   @db.Text
  country            String?   @db.VarChar(2)
  region             String?   @db.VarChar(100)
  city               String?   @db.VarChar(100)
  metadata           Json?     @default("{}")

  @@index([connection_id])
  @@index([ip_address])
  @@index([wallet_address])
  @@index([connected_at])
  @@index([disconnected_at])
  @@index([is_authenticated])
  @@map("websocket_connections")
}

model client_errors {
  id              Int       @id @default(autoincrement())
  error_id        String    @unique // Unique identifier for grouping similar errors
  wallet_address  String?   @db.VarChar(44)
  user_id         Int?      // References users.id
  message         String    @db.Text
  level           String    @default("error") @db.VarChar(20)
  stack_trace     String?   @db.Text
  source_url      String?   @db.Text
  line_number     Int?
  column_number   Int?
  browser         String?   @db.VarChar(100)
  browser_version String?   @db.VarChar(50)
  os              String?   @db.VarChar(50)
  device          String?   @db.VarChar(50)
  ip_address      String?   @db.VarChar(45)
  session_id      String?   @db.VarChar(100)
  environment     String?   @db.VarChar(20) // 'production', 'development', etc.
  status          String?   @default("open") @db.VarChar(20)
  resolved_at     DateTime? @db.Timestamptz(6)
  resolved_by     String?   @db.VarChar(44)
  resolution_note String?   @db.Text
  is_critical     Boolean?  @default(false)
  occurrences     Int       @default(1)
  last_occurred_at DateTime? @default(now()) @db.Timestamptz(6)
  created_at      DateTime  @default(now()) @db.Timestamptz(6)
  metadata        Json?     @default("{}")
  tags            String[]
  
  user            users?    @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@index([wallet_address], map: "idx_client_errors_wallet")
  @@index([status], map: "idx_client_errors_status")
  @@index([created_at], map: "idx_client_errors_created")
  @@index([last_occurred_at], map: "idx_client_errors_occurred")
  @@index([is_critical], map: "idx_client_errors_critical")
  @@index([session_id], map: "idx_client_errors_session")
  @@map("client_errors")
}

model config_solana_engine {
  id                 String    @id @default(cuid())
  
  // Cache Configuration
  token_metadata_ttl Int       @default(86400)    // Token metadata cache TTL in seconds (24h default)
  token_price_ttl    Int       @default(3600)     // Token price cache TTL in seconds (1h default)
  wallet_data_ttl    Int       @default(300)      // Wallet data cache TTL in seconds (5m default)
  
  // RPC Configuration
  connection_strategy String    @default("adaptive") // "round-robin", "weighted", or "adaptive"
  health_check_interval Int     @default(60000)    // Health check interval in ms
  failure_threshold   Int       @default(2)        // Failures before marking endpoint unhealthy
  recovery_threshold  Int       @default(3)        // Successes before marking endpoint healthy again
  
  // Rate Limiting
  max_concurrent_requests Int   @default(5)        // Maximum concurrent requests
  request_spacing_ms   Int      @default(100)      // Minimum time between operations
  base_backoff_ms      Int      @default(250)      // Base backoff time for retries
  
  // Endpoint Weights (stored as JSON)
  endpoint_weights    Json?     @default("{}")     // Custom weights for specific endpoints
  
  // Admin Features
  admin_bypass_cache  Boolean   @default(false)    // Whether admin operations bypass cache by default
  
  // Metadata
  last_updated        DateTime  @default(now()) @updatedAt
  updated_by          String?   @db.VarChar(44)    // Admin who made the change
  
  @@map("config_solana_engine")
}

model config_contest_wallet {
  id                     String    @id @default(cuid())
  
  // Core Configuration
  check_interval_ms      Int       @default(60000)    // Check interval in milliseconds (1 min default)
  
  // Reclaim Settings
  min_balance_to_reclaim Decimal   @default(0.05) @db.Decimal(10, 8)   // Minimum SOL balance to reclaim
  min_amount_to_transfer Decimal   @default(0.01) @db.Decimal(10, 8)   // Minimum amount to transfer back
  reclaim_contest_statuses Json     @default("[\"completed\", \"cancelled\"]") // Contest statuses for reclaim
  
  // Vanity Wallet Settings
  vanity_wallet_paths    Json      @default("{\"DUEL\":\"/home/websites/degenduel/addresses/keypairs/public/_DUEL\", \"DEGEN\":\"/home/websites/degenduel/addresses/keypairs/public/_DEGEN\"}")
  
  // Wallet Encryption
  encryption_algorithm   String    @default("aes-256-gcm")  // Encryption algorithm for wallet keys
  
  // Circuit Breaker
  failure_threshold      Int       @default(5)      // Failures before circuit breaker trips
  reset_timeout_ms       Int       @default(60000)  // Reset timeout in milliseconds
  min_healthy_period_ms  Int       @default(120000) // Min time to consider service healthy
  
  // Backoff Settings
  initial_delay_ms       Int       @default(1000)   // Initial delay for backoff
  max_delay_ms           Int       @default(30000)  // Maximum delay for backoff
  backoff_factor         Int       @default(2)      // Multiplier for backoff
  
  // Admin Features
  enable_vanity_wallets  Boolean   @default(true)    // Whether to use vanity wallets for contests
  
  // Metadata
  last_updated           DateTime  @default(now()) @updatedAt
  updated_by             String?   @db.VarChar(44)    // Admin who made the change
  
  @@map("config_contest_wallet")
}

model config_admin_wallet {
  id                      String    @id @default(cuid())
  
  // Core Configuration
  check_interval_ms       Int       @default(60000)    // Check interval in milliseconds (1 min default)
  
  // Wallet Settings
  min_sol_balance         Decimal   @default(0.05) @db.Decimal(10, 8)   // Minimum SOL balance to maintain
  max_parallel_transfers  Int       @default(5)      // Max number of transfers to process in parallel
  transfer_timeout_ms     Int       @default(30000)  // Timeout for transfer operations
  max_batch_size          Int       @default(50)     // Maximum batch size for operations
  
  // Wallet Encryption
  encryption_algorithm    String    @default("aes-256-gcm")  // Encryption algorithm
  key_length              Int       @default(32)     // Encryption key length
  iv_length               Int       @default(16)     // Initialization vector length
  tag_length              Int       @default(16)     // Authentication tag length
  
  // Circuit Breaker
  failure_threshold       Int       @default(7)      // Failures before circuit breaker trips
  reset_timeout_ms        Int       @default(80000)  // Reset timeout in milliseconds
  min_healthy_period_ms   Int       @default(150000) // Min time to consider service healthy
  
  // Backoff Settings
  initial_delay_ms        Int       @default(1000)   // Initial delay for backoff
  max_delay_ms            Int       @default(30000)  // Maximum delay for backoff
  backoff_factor          Int       @default(2)      // Multiplier for backoff
  
  // Security Settings
  require_admin_approval  Boolean   @default(true)   // Whether large transfers require approval
  large_transfer_threshold Decimal  @default(10.0) @db.Decimal(10, 8)  // Threshold for "large" transfers
  
  // Metadata
  last_updated            DateTime  @default(now()) @updatedAt
  updated_by              String?   @db.VarChar(44)  // Admin who made the change
  
  @@map("config_admin_wallet")
}

model config_ai_service {
  id                       String    @id @default(cuid())
  
  // Core Configuration
  check_interval_ms        Int       @default(600000)   // Check interval (10 min default)
  
  // Analysis Settings
  client_error_lookback_minutes Int  @default(10)       // Minutes to look back for client errors
  min_errors_to_analyze    Int       @default(1)        // Minimum errors to trigger analysis
  admin_action_lookback_minutes Int  @default(15)       // Minutes to look back for admin actions
  min_actions_to_analyze   Int       @default(1)        // Minimum actions to trigger analysis
  
  // Model Configurations (as JSON for flexibility)
  model_loadouts           Json      @default("{\"default\":{\"model\":\"gpt-4.1-mini\",\"maxTokens\":4048,\"temperature\":0.4},\"errorAnalysis\":{\"model\":\"gpt-4.1-mini\",\"maxTokens\":4048,\"temperature\":0.4},\"adminAnalysis\":{\"model\":\"gpt-4.1-mini\",\"maxTokens\":4048,\"temperature\":0.4}}")
  
  // System Prompts (as JSON)
  system_prompts           Json      @default("{}")     // System prompts for different tasks
  
  // Circuit Breaker
  failure_threshold        Int       @default(3)        // Failures before circuit breaker trips
  reset_timeout_ms         Int       @default(30000)    // Reset timeout in milliseconds
  
  // Rate Limiting
  max_tokens_per_minute    Int       @default(100000)   // Token rate limit for API calls
  max_conversations_per_user Int     @default(5)        // Max concurrent conversations per user
  
  // Feature Flags
  enable_error_analysis    Boolean   @default(true)     // Whether to enable error analysis
  enable_admin_analysis    Boolean   @default(true)     // Whether to enable admin action analysis
  enable_user_ai_convos    Boolean   @default(true)     // Whether to enable user AI conversations
  
  // Metadata
  last_updated             DateTime  @default(now()) @updatedAt
  updated_by               String?   @db.VarChar(44)    // Admin who made the change
  
  @@map("config_ai_service")
}

model rpc_benchmark_results {
  id              Int       @id @default(autoincrement())
  test_run_id     String    // Unique identifier for test run batch
  timestamp       DateTime  @default(now())
  provider        String    // RPC provider name (e.g., "Helius", "BranchRPC")
  method          String    // RPC method tested (e.g., "getLatestBlockhash")
  test_type       String    // Type of test (e.g., "rpc", "network")
  min_latency     Float?    // Minimum latency in ms
  max_latency     Float?    // Maximum latency in ms
  avg_latency     Float?    // Average latency in ms
  median_latency  Float?    // Median latency in ms
  stdev           Float?    // Standard deviation of latencies
  success_count   Int       @default(0)
  failure_count   Int       @default(0)
  raw_latencies   Json?     // Raw latency measurements as JSON array
  notes           String?   // Optional notes about the test

  @@index([test_run_id])
  @@index([provider])
  @@index([method])
  @@index([timestamp])
  @@map("rpc_benchmark_results")
}

// Token rank history information
model token_rank_history {
  id          Int       @id @default(autoincrement())       // id
  token_id    Int                                           // Foreign key to tokens table
  rank        Int                                           // Position in ranking (1-1000+)
  timeframe   String?   @db.VarChar(20)                     // [new 4/25/25] options are 5m, 1h, 6h, 24h (i think?)
  timestamp   DateTime  @default(now()) @db.Timestamptz(6)  // ts
  source      String?   @db.VarChar(50)                     // Source of ranking data (e.g. 'jupiter', 'manual')
  snapshot_id String?   @db.VarChar(100)                    // Optional batch ID for grouping ranks from same update
  
  // Relations
  tokens      tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([rank]) // Index for querying tokens by rank
  @@map("token_rank_history")
}

// Volume history table for tracking token volume over time
model token_volume_history {
  id          Int       @id @default(autoincrement())
  token_id    Int       // Foreign key to tokens table
  volume      Decimal   @db.Decimal(20, 0) // Volume in smallest token units
  volume_usd  Decimal?  @db.Decimal(20, 2) // Volume in USD (if available)
  change_24h  Decimal?  @db.Decimal(5, 2)  // 24h volume change percentage
  timestamp   DateTime  @default(now()) @db.Timestamptz(6)
  source      String?   @db.VarChar(50)    // Source of volume data (e.g. 'jupiter', 'coingecko')
  snapshot_id String?   @db.VarChar(100)   // Optional batch ID for grouping from same update
  
  // Relations
  tokens      tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([volume_usd(sort: Desc)]) // For quickly finding high volume tokens
  @@map("token_volume_history")
}

// Liquidity history table for tracking token liquidity over time
model token_liquidity_history {
  id          Int       @id @default(autoincrement())
  token_id    Int       // Foreign key to tokens table
  liquidity   Decimal   @db.Decimal(20, 0) // Liquidity in smallest token units
  change_24h  Decimal?  @db.Decimal(5, 2)  // 24h liquidity change percentage
  timestamp   DateTime  @default(now()) @db.Timestamptz(6)
  source      String?   @db.VarChar(50)    // Source of liquidity data
  snapshot_id String?   @db.VarChar(100)   // Optional batch ID for grouping from same update
  
  // Relations
  tokens      tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([liquidity(sort: Desc)]) // For quickly finding high liquidity tokens
  @@map("token_liquidity_history")
}

// Market cap history table for tracking token market cap over time
model token_market_cap_history {
  id          Int       @id @default(autoincrement())
  token_id    Int       // Foreign key to tokens table
  market_cap  Decimal   @db.Decimal(20, 0) // Market cap in smallest units
  fdv         Decimal?  @db.Decimal(20, 0) // Fully diluted valuation if available
  change_24h  Decimal?  @db.Decimal(5, 2)  // 24h market cap change percentage
  timestamp   DateTime  @default(now()) @db.Timestamptz(6)
  source      String?   @db.VarChar(50)    // Source of market cap data
  snapshot_id String?   @db.VarChar(100)   // Optional batch ID for grouping from same update
  
  // Relations
  tokens      tokens    @relation(fields: [token_id], references: [id], onDelete: Cascade)

  @@index([token_id])
  @@index([timestamp(sort: Desc)])
  @@index([token_id, timestamp(sort: Desc)])
  @@index([market_cap(sort: Desc)]) // For quickly finding high market cap tokens
  @@map("token_market_cap_history")
}

model token_pools {
  address       String   @db.Text
  tokenAddress  String   @db.Text
  token         tokens   @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)
  dex           String   @db.Text // RAYDIUM_AMM_V4, PUMP_SWAP, etc.
  programId     String   @db.Text // The program address
  dataSize      Int      // Size of the account data
  tokenOffset   Int      // Offset where token address is found
  createdAt     DateTime @default(now())
  lastUpdated   DateTime @updatedAt

  @@id([address, tokenAddress])
  @@index([dex])
  @@index([tokenAddress])
  @@map("token_pools")
}

model monitored_tokens {
  token_address         String    @id @db.VarChar(44)
  token_name            String?
  token_symbol          String?
  decimals              Int       @default(9)
  monitor_buys          Boolean   @default(true)
  monitor_sells         Boolean   @default(true)
  min_transaction_value Decimal   @default(0) @db.Decimal(20, 8)
  created_at            DateTime  @default(now()) @db.Timestamptz(6)
  updated_at            DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  token                 tokens    @relation(fields: [token_address], references: [address], onDelete: Cascade, onUpdate: Cascade)

  @@map("monitored_tokens")
}

model token_config {
  id                          Int      @id @default(autoincrement())
  address                     String?  @db.VarChar(44)
  symbol                      String   @db.VarChar(10)
  total_supply                BigInt
  initial_circulating         BigInt
  community_allocation_percent Int
  team_allocation_percent     Int
  treasury_allocation_percent Int
  initial_price               Decimal  @db.Decimal(20, 10)
  launch_method               String   @db.VarChar(50)

  @@map("token_config")
}

model contest_schedule {
  id                  Int               @id @default(autoincrement())
  name                String            // Name of the schedule
  template_id         Int               // References contest_templates
  hour                Int?              // Hour of day (0-23)
  minute              Int?              @default(0) // Minute of hour (0-59)
  days                Int[]             // Days of week (0=Sunday, 6=Saturday) 
  entry_fee_override  Decimal?          @db.Decimal(20, 8) // Optional override of template fee
  name_override       String?           // Optional override of contest name
  description_override String?          // Optional override of contest description
  duration_hours      Float?            @default(1.0) // Duration in hours
  enabled             Boolean           @default(true) // Whether this schedule is active
  advance_notice_hours Int?             @default(1) // Hours in advance to create contest
  min_participants_override Int?        // Override min participants from template
  max_participants_override Int?        // Override max participants from template
  allow_multiple_hours Boolean          @default(false) // For tri-hourly type schedules
  multiple_hours      Int[]             // Array of hours for multiple hour schedules
  created_at          DateTime          @default(now()) @db.Timestamptz(6)
  updated_at          DateTime          @updatedAt @db.Timestamptz(6)
  template            contest_templates @relation(fields: [template_id], references: [id])
  contests            contests[]

  @@index([enabled])
  @@index([template_id])
  @@map("contest_schedule")
}

model roadmap_phases {
  id             Int            @id @default(autoincrement())
  quarter_number Int
  year           Int
  title          String         @db.VarChar(100)
  tasks          roadmap_tasks[]

  @@map("roadmap_phases")
}

model roadmap_tasks {
  id          Int           @id @default(autoincrement())
  phase_id    Int
  description String        @db.Text
  phase       roadmap_phases @relation(fields: [phase_id], references: [id])

  @@map("roadmap_tasks")
}

model platform_stats {
  id               Int      @id @default(autoincrement())
  user_count       Int      @default(0)
  upcoming_contests Int      @default(0)
  total_prize_pool Decimal  @default(0)
  waitlist_count   Int      @default(0)

  @@map("platform_stats")
}

model terminal_commands {
  id               Int      @id @default(autoincrement())
  command_name     String   @unique @db.VarChar(50)
  command_response String   @db.Text

  @@map("terminal_commands")
}

model pool_price_changes {
  id              Int      @id @default(autoincrement())
  tokenAddress    String   @db.VarChar(44)
  poolAddress     String   @db.Text
  price           Decimal  @db.Decimal(20, 8)
  previousPrice   Decimal  @db.Decimal(20, 8)
  changePercent   Decimal  @db.Decimal(10, 2)
  liquidity       Decimal  @db.Decimal(20, 0) @default(0)
  timestamp       DateTime @default(now()) @db.Timestamptz(6)
  token           tokens   @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)

  @@index([tokenAddress])
  @@index([poolAddress])
  @@index([timestamp(sort: Desc)])
  @@index([tokenAddress, timestamp(sort: Desc)])
  @@index([changePercent(sort: Desc)])
  @@map("pool_price_changes")
}

// Token refresh priority configuration
model token_refresh_priority_tiers {
  id                        Int       @id @default(autoincrement())
  name                      String    @unique @db.VarChar(50) // e.g., "CRITICAL", "HIGH", etc.
  description               String?   @db.Text
  
  // Core configuration
  priority_score            Int       // Priority score used for sorting (higher = refreshed sooner)
  refresh_interval_seconds  Int       // Base refresh interval in seconds
  rank_threshold            Int       // Maximum rank for this tier
  
  // Advanced settings
  volatility_factor         Float     @default(1.0)  // Multiplier for adjusting intervals based on volatility
  max_tokens_per_batch      Int?      // Maximum tokens per batch for this tier (null = use global default)
  batch_delay_ms            Int?      // Delay between batches for this tier (null = use global default)
  
  // Tokens in this tier (virtual relationship - not stored)
  token_count               Int       @default(0)    // Number of tokens currently in this tier
  
  // Admin metadata
  created_at                DateTime  @default(now()) @db.Timestamptz(6)
  updated_at                DateTime  @updatedAt @db.Timestamptz(6)
  updated_by                String?   @db.VarChar(44) // Admin who updated this tier
  is_active                 Boolean   @default(true)  // Whether this tier is currently active
  
  @@index([priority_score])
  @@index([refresh_interval_seconds])
  @@index([rank_threshold])
  @@index([is_active])
  @@map("token_refresh_priority_tiers")
}
